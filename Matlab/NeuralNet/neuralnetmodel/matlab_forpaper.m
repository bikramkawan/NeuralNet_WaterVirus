% Solve an Autoregression Problem with External Input with a NARX Neural Network
% Script generated by Neural Time Series app
% Created 21-Feb-2016 01:32:24
%
% This script assumes these variables are defined:
%
%   inputs - input time series.
%   targets - feedback time series.


close all; clear;

data =load('../vessel_status_old.txt');
addpath('../jsonlab');
%data=data(:,2:11);
%speed = module2(:,3);
surge_vel=data(2000:6000,2); % Surge_ Velocity

sway_vel=data(2000:6000,3); % sway Velocity
yaw_vel=data(2000:6000,4); % Yaw Veloctiy
% roll_vel= data(2000:6000,5);%Roll Velocity
% pitch_vel = data(2000:6000,6); %Pitch Velocity
pos_x= data(:,5); %Position East 
pos_y= data(:,6); % Position North
heading = data(:,7); %Heading
% roll = data(2000:6000,2); %Roll
% pitch = data(2000:6000,2); % Pitch


%Filter Data Example
%surge_vel_new=(surge_vel(surge_vel>2.1 & surge_vel<6));


inputs=[pos_x pos_y];

targets = [pos_x pos_y];
X = tonndata(inputs,false,false);
T = tonndata(targets,false,false);

% Choose a Training Function
% For a list of all training functions type: help nntrain
% 'trainlm' is usually fastest.
% 'trainbr' takes longer but may be better for challenging problems.
% 'trainscg' uses less memory. Suitable in low memory situations.
trainFcn = 'trainlm';  % Levenberg-Marquardt backpropagation.

% Create a Nonlinear Autoregressive Network with External Input
inputDelays = 1:2;
feedbackDelays = 1:2;
hiddenLayerSize = 10;
net = narxnet(inputDelays,feedbackDelays,hiddenLayerSize,'open',trainFcn);

% Prepare the Data for Training and Simulation
% The function PREPARETS prepares timeseries data for a particular network,
% shifting time by the minimum amount to fill input states and layer
% states. Using PREPARETS allows you to keep your original time series data
% unchanged, while easily customizing it for networks with differing
% numbers of delays, with open loop or closed loop feedback modes.
[x,xi,ai,t] = preparets(net,X,{},T);

% Setup Division of Data for Training, Validation, Testing
 %2000
net.divideFcn = 'divideind';
  trainInd=3000:6000;
  valInd=7000:8000;
  testInd=1:2000;
  
  
  net.divideParam.trainInd= trainInd;
  net.divideParam.valInd= valInd;
  net.divideParam.testInd=testInd;

% Default 
%   net.divideParam.trainRatio = 10/100;
%   net.divideParam.valRatio = 15/100;
%   net.divideParam.testRatio = 15/100;

% Train the Network
[net,tr] = train(net,x,t,xi,ai);

% Test the Network
y = net(x,xi,ai);
e = gsubtract(t,y);
performance = perform(net,t,y)

% View the Network
%view(net);

% Plots
% Uncomment these lines to enable various plots.
%figure, plotperform(tr)
%figure, plottrainstate(tr)
%figure, ploterrhist(e)
%figure, plotregression(t,y)
%figure, plotresponse(t,y)
%figure, ploterrcorr(e)
%figure, plotinerrcorr(x,e)

% Closed Loop Network
% Use this network to do multi-step prediction.
% The function CLOSELOOP replaces the feedback input with a direct
% connection from the outout layer.
netc = closeloop(net);
netc.name = [net.name ' - Closed Loop'];
%view(netc);
[xc,xic,aic,tc] = preparets(netc,X,{},T);
yc = netc(xc,xic,aic);
closedLoopPerformance = perform(net,tc,yc)

% Step-Ahead Prediction Network
% For some applications it helps to get the prediction a timestep early.
% The original network returns predicted y(t+1) at the same time it is
% given y(t+1). For some applications such as decision making, it would
% help to have predicted y(t+1) once y(t) is available, but before the
% actual y(t+1) occurs. The network can be made to return its output a
% timestep early by removing one delay so that its minimal tap delay is now
% 0 instead of 1. The new network returns the same outputs as the original
% network, but outputs are shifted left one timestep.
nets = removedelay(net);
nets.name = [net.name ' - Predict One Step Ahead'];
%view(nets);
[xs,xis,ais,ts] = preparets(nets,X,{},T);
ys = nets(xs,xis,ais);
stepAheadPerformance = perform(nets,ts,ys)

% Plot 
length=2000;
output = cell2mat(ys);
output=output';
plot(output(1:length,1),output(1:length,2));

hold on 
plot(inputs(1:length,1),inputs(1:length,2));
legend('Outputs','Inputs');


%%JSON

neuraloutputjson=output(1:2000,:);
actualtrajectory=inputs(1:2000,:);
heading1=heading(1:2000);
field1 = 'Predicted';
value1 = {neuraloutputjson};
field2 = 'Actual';
value2 = {actualtrajectory};
field3 = 'Heading';
value3 = {heading1};

jsondata = struct(field1,value1,field2,value2,field3,value3);
savejson('neuralnetresult',jsondata,'neuralnetresult.json');